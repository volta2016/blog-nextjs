---
title: "Side Effects - useEffect"
image: "/static/images/side-effects-useeffect.jpg"
cover: "/static/images/opengraph/side-effects-useeffect.jpg"
author: "/static/images/author-voltadev.png"
nameauthor: "voltadev"
published: "06-06-2022"
description: "Side Effects useEffect a detalle"
---

> Hola bienvenidos al blog üòÄ este post lo voy dividir en 2 para poder explicar a profundidad lo que
> es un side Effects y el hook useEffect

## Efectos secundarios (Side Effects)

En programaci√≥n, llamamos efectos secundarios a las modificaciones que alteran el
estado de nuestro programa. Vamos a verlo en t√©rminos pr√°cticos comparando dos funciones:

```js
(x,y) => x + y

nombre = ‚Äú‚Äù;
(value) => nombre = value;
```

<br />

Decimos que la primera funci√≥n no produce efectos secundarios, porque la ejecuci√≥n de
la misma no altera nada fuera del alcance de esta funci√≥n. Podemos ejecutar esta funci√≥n
cuantas veces queramos y nada cambiar√°.

<br />

Por otro lado, la segunda funci√≥n cambia una variable fuera de la ejecuci√≥n de la
funci√≥n, alterando el estado de la App. Este es un efecto secundario.

<br />

Cuando hablamos de React, si el componente ejecuta una operaci√≥n que altera el estado
global de la app, estar√≠amos produciendo un efecto secundario. En general, un componente
debe hacer operaciones que alteren al componente mismo, y no m√°s. Por supuesto que
hay muchas excepciones, sin embargo, hay que tener en cuenta que el c√≥digo que no
produce efectos secundarios es menos impredecible y m√°s f√°cil de debuggear.

<br />

Algunos ejemplos de efectos secundarios en un componente pueden ser: realizar peticiones
a un servidor con AJAX, alterar el DOM manualmente, conectarse a una websocket, etc.

<br />

En un componente funcional, estas operaciones no se pueden ejecutar, ya que las funciones
de un componente, no producen efectos secundarios.

<br />

Para poder ejecutar operaciones que produzcan efectos secundarios, podemos usar el
hook **useEffect.**

<br />

**useEffect** nos permite enviar una funci√≥n que se ejecutar√° luego del render de
una funci√≥n. Esta funci√≥n puede producir efectos secundarios, de ah√≠ el nombre del
**hook useEffect.**

<br />

## En t√©rminos pr√°cticos, useEffect es el lugar perfecto para:

- <span className="list-icon">‚úÖ </span> <b>
    Ejecutar c√≥digo como parte del ciclo de vida del componente
  </b>
- <span className="list-icon">‚úÖ </span> <b>Hacer peticiones AJAX</b>
- <span className="list-icon">‚úÖ </span> <b>
    Actualizar el DOM directamente, por ejemplo para reproducir un v√≠deo
  </b>
- <span className="list-icon">‚úÖ </span> <b>Logging de cambios</b>

<br />

**useEffect** recibe como segundo argumento que es un arreglo.
En **este arreglo pueden pasar variables que se usar√°n para determinar si el efecto debe ejecutarse o no.**
En la documentaci√≥n de React podemos ver un muy buen ejemplo:

```jsx import React, {(useState, useEffect)} from "react";
function Example() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  }, [count]); // Solo se ejecuta si count cambi√≥ entre un render y otro

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

<br />

Cuando pasamos un arreglo vac√≠o, **useEffect s√≥lo se ejecutar√° una vez luego del primer render.**

Por √∫ltimo, si una funci√≥n se retorna del efecto, √©sta se ejecutar√° luego del √∫ltimo render una vez
que el componente desaparezca de la interfaz.

## Side Effects y useEffect üòé ¬ø Cu√°ndo se ejecuta ?

El principal objetivo de react es proporcionar la mejor experiencia de usuario posible y para eso
hay que ser capaces de distinguir entre lo que es "importante y lo que es necesario" entre lo prioritario
y lo que puede esperar.

<br />

**"La prioridad m√°xima de una aplicaci√≥n" es reaccionar ante las acciones del usuario y proporcionar una respuesta visual r√°pida y efectiva, esta respuesta visual implica realizar cambios sobre nuestra interfaz y para hacerlo sabemos que tenemos que provocar un renderizado que al final terminar√° de ACTUALIZAR EL DOM, pero esto no es lo √∫nico que debe hacer una aplicaci√≥n**

<br />

Podemos establecer una premisa, que la prioridad m√°xima cuando el usuario realiza una b√∫squeda,
es ofrecer esta respuesta oficial inmediata mostrando este spiner.

<br />

![spinner](/static/images/spinner.png "spinner")

<br />

A continuaci√≥n y como consecuencia de esta busqueda hay varias tareas adicionales que nuestra App
debe realizar, que si bien no son tan importantes, en esta primera estapa son completamente necesarias, para que
funcione completamente. Ejemplos de estas tareas:

<br />

- <span className="list-icon">‚úÖ </span> a√±adir un query string a esta URL -> Cambiar
  URL
- <span className="list-icon">‚úÖ </span> cambiar el t√≠tulo de la pesta√±a -> Cambiar
  t√≠tulo
- <span className="list-icon">‚úÖ </span> realizar la petici√≥n a la API para obtener
  los resultados -> API de b√∫squeda
- <span className="list-icon">‚úÖ </span>registrar las m√©tricas en nuestro
  servidor

<br />

![Consecuencias useEffect](/static/images/consecuencias-useEffect.png)

<br />

Desde el punto de vista del **usuario** todas estas acciones son secundarias.

<br />

Desde del punto de vista del **desarrollador** son efectos secundarios **(side effects)** de la
acci√≥n principal, para poder gestionarlos correctamente. React nos proporciona el Hook de **useEffect "hook para efectos secundarios"**
pero antes de ver como funciona hay que entender a que nos referimos cuando hablamos de side effects.

## Side effects

Consecuencia de otras acciones -> en este caso como consecuencia de un cambio de estado

<br />

- <span className="list-icon">‚òëÔ∏è </span> Se ejecuta siempre despu√©s de la acci√≥n
  principal -> en este caso despu√©s del renderizado

- <span className="list-icon">‚òëÔ∏è </span> El orden en que se ejecutan es irrelevante

- <span className="list-icon">‚òëÔ∏è </span> Implicaciones externas

<br />

En este caso podemos actualizar:

<br />

- <span className="list-icon">‚úÖ </span> t√≠tulo
- <span className="list-icon">‚úÖ </span> URL
- <span className="list-icon">‚úÖ </span> llamada a la API

<br />

Si es al rev√©s su orden, el resultado final ser√≠a el mismo y tendr√≠a implicaciones externas a la propia funci√≥n que los define, mientras que un renderizado deber√≠a afectar s√≥lo al nodo que se renderiza o cualquiera de sus hijos. Un **side effects** puede afectar a elementos externos al propio DOM -> como son el document title, la location href o a la propia red que utilizamos para la llamada a la API

<br />

üìö **side effects es el cambio de un estado principal**

## Distinguir side effects

- <span className="list-icon">‚úÖ </span> Definir la tarea que vamos a realizar ->
  por ejemplo realizar esta b√∫squeda

- <span className="list-icon">‚úÖ </span> Detectar las acciones -> en que se divide
  esta tarea. Podemos considerar una acci√≥n como el m√≠nimo de conjuntos de operaciones
  necesarias para poder producir un resultado relevante. Cambiar el valor de una
  variable es una operaci√≥n, pero no produce un resultado relevante por s√≠ misma.
  Mientras que modificar el t√≠tulo del documento o modificar la url, aunque tambi√©n
  son simples operaciones, producen un resultado relevante. Eso ser√≠a la diferencia
  entre una operaci√≥n y una acci√≥n como tal, que puede incluir una o varias operaciones.

<br />

**Podemos entender estas acciones tambi√©n como las distintas responsabilidades que existen dentro de la tarea**

<br />

- <span className="list-icon">‚úÖ </span> Elegir la acci√≥n principal -> una vez tengamos
  esta acci√≥n principal

- <span className="list-icon">‚úÖ </span> El resto de acciones ser√°n side effects
  (acci√≥n del usuario en la UI)

<br />

üëÄ Lo m√°s importante que hay que entender, es elegir cu√°l es la acci√≥n principal, implica tomar
una decisi√≥n y que no siempre existe una √∫nica respuesta, En muchos casos la acci√≥n principal
estar√° totalmente clara pero en otros sera algo completamente debatible y tendr√° que determinarse
en base a lo que nosotros consideramos m√°s prioritario. Como en todo tenemos que tomar una decisi√≥n
y en base a ella actuar en consecuencia.

<br />

```jsx
import { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);
  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
          document.title = count + 1;
        }}
      >
        + 1
      </button>
    </div>
  );
};

export default App;
```

Vamos a ver como podemos conseguir que el valor de este contador
cambie el titulo de pesta√±a para indicar el valor, aqu√≠ es donde tenemos que comenzar a analizar.
Tenemos que comenzar a pensar en esa tarea, cual ser√≠a la tarea para incrementar ese contador
y de esa tarea tenemos varias acciones.

<br />

- <span className="list-icon">‚úÖ </span> este setCount ser√≠a una acci√≥n que produce
  alg√∫n resultado relevante -> si actualiza la interfaz

- <span className="list-icon">‚úÖ </span> este document.title = count + 1 es una acci√≥n
  o no -> produce otro resultado relevante, en este caso actualizar el t√≠tulo de
  la pesta√±a

<br />

Por lo tanto aqu√≠ tenemos una tarea que se divide en 2 acciones, ahora cual es la acci√≥n principal que terminamos aqu√≠, Por un lado tenemos el setCount que es actualizar el state y este se renderiza en pantalla. Aqu√≠ tenemos la respuesta visual m√°s inmediata del usuario. Donde el usuario va a centrar su foco de atenci√≥n, el **document.title** no tiene mucho sentido si actualizo la app, actualiza la pesta√±a una vez si quito el setCount y a partir de aqu√≠ no tiene mucho sentido, entonces podemos decir claramente que de las 2, la acci√≥n principal seria **setCount** y document.title = count + 1 ser√≠a un **side effect.**

Sabiendo que es un side effects cual es problema de gestionarlo de esta manera y porque no debemos hacerlo. Esto se ve claramente cuando comenzamos a a√±adir mas cosas a esta aplicaci√≥n.

```jsx
import { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);
  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
          document.title = count + 1;
        }}
      >
        + 1
      </button>
      <button
        onClick={() => {
          setCount(count + 2);
          document.title = count + 2;
        }}
      >
        + 2
      </button>
    </div>
  );
};

export default App;
```

<br />

Como ven aqu√≠ lo que estoy haciendo es traer toda esta acci√≥n principal, que evidentemente
no puedo quitarla de aqu√≠. El boton tiene que tener un acci√≥n principal, pero cada vez que
modifico este contador tengo que venir acompa√±ando con su side effects asociado, es decir
yo modifico este contador -> en el momento que yo haga este setCount tengo que venir detr√°s
con el sideEffect y si hago este setCount en 10 sitios, tengo que asegurarme que est√© sideEffects
y todos los dem√°s que tenga asociado se ejecutan siempre detr√°s y eso es algo que nos puede inducir a un error.

<br />

üòÄ Actualizo y todo bien

<br />

<Image
  src="/static/images/setcount2.png"
  alt="setcount2"
  width={190}
  height={220}
/>

<br />

¬ø Pero qu√© pasa que por alguna acci√≥n casual hago un setCount y se me olvida poner este **document.title** ?
Si alg√∫n punto se nos olvida hacer esta peque√±a modificaci√≥n, el reultado ser√≠a una App con
un state inconsistente.

<br />

Si aplico el **bot√≥n mas 1** -> tengo el 1 en la pesta√±a
Pero si aplico el **bot√≥n +2** -> solamente actualiza el contador y no hago el document.title

<br />

Ademas tenemos otro punto en contra con estos **side effects:** hasta que no termina toda esta
acci√≥n el renderizado no se produce.
Es decir este render no se inicia cuando hacemos setCount -> si no que tiene que esperar a este
document.title en este caso es una operaci√≥n muy sencilla.

<br />

Imagina que esto tarda medio segundo, estar√≠amos bloqueando ese renderizado medio segundo, hasta que
termine de hacer todo, lo cual no tiene sentido. Podemos priorizar la acci√≥n principal y dejar que
se produzca el renderizado, posteriormente cuando acabe el renderizado ya realizar todos
esos sideEffects, porque no nos importa ni el orden en que se ejecuten, ni nos importa exactamente
el orden en que lo haga despu√©s de la acci√≥n principal y antes de la siguiente nos sirve perfectamente
y da igual si es en medio segundo antes o medio segundo despu√©s, no hay ning√∫n problema y para
eso tenemos el hook de **useEffects.**

<br />

## ‚öì useEffect

üëÅÔ∏è Al ser un hook, tiene que llamarse siempre dentro de un componente el primer par√°metro que recibe este useEffect:

<br />

- <span className="list-icon">‚úÖ </span> <b>
    es una funci√≥n -> **se ejecutar√° siempre despu√©s del renderizado y tendr√°
    los valores actualizados
  </b>

<br />

```jsx
import { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = count; // este count ya est√° actualizado
  });

  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        + 1
      </button>
      <button
        onClick={() => {
          setCount(count + 2);
        }}
      >
        + 2
      </button>
    </div>
  );
};

export default App;
```

<br />

ahora lo que conseguimos es que cambie el estado de count

<br />

```jsx
useEffect(() => {
  document.title = count; // este count ya esta actualizado
});
```

<br />

si lo hacemos con tanto con un **+1** o un **+2,** siempre que cambie el **state de count,** da igual que lo hagamos desde un bot√≥n, desde otro o inclusive desde un tercero, siempre provocaremos un **side effects** que consiga exactamente esto

```jsx
import { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = count; // este count ya esta actualizado
    console.log(count);
  });

  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        + 1
      </button>
      <button
        onClick={() => {
          setCount(count + 2);
        }}
      >
        + 2
      </button>
      <button
        onClick={() => {
          setCount(count + 3);
        }}
      >
        + 3
      </button>
    </div>
  );
};

export default App;
```

<br />

<Image
  src="/static/images/setcount3.png"
  alt="setcount3"
  width={190}
  height={220}
/>

<br />

Le doy +1,+2,+3

<br />

Lo que acabamos de hacer es vincular este count a un side effects y nos da igual donde se ejecuta este count, nos da igual que si lo seteamos 1 2 o 7 veces da igual, no hay que preocuparse por esos side effects, vamos hacer un console.log(count) entendi√©ndolo como un peque√±o side effects. No se habla de sideEffects porque no deber√≠a haber un console.log en producci√≥n, pero si ciertamente ser√≠a como un peque√±o side effects
para explicar este ejemplo.

## Ahora lo que tenemos que entender ¬ø Cuando se ejecuta este useEffects y por qu√© funciona as√≠ ? ¬ø por qu√© tiene los valores actualizados de {count} ?

Vamos a ir analizando con los console.log() que es lo que sucede

```jsx
import { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  console.log("%c 1: render antes useEffect ", "color: MediumSpringGreen");

  useEffect(() => {
    console.log("useEffect", count);
    document.title = count; // este count ya esta actualizado
  });

  console.log("%c 2: render despu√©s useEffect ", "color: LightCoral");

  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        + 1
      </button>
      <button
        onClick={() => {
          setCount(count + 2);
        }}
      >
        + 2
      </button>
      <button
        onClick={() => {
          setCount(count + 3);
        }}
      >
        + 3
      </button>
    </div>
  );
};

export default App;
```

Cuando nosotros carguemos nuestra App por primera vez, inicialmente lo que vamos a provocar es el primer renderizado. Haremos este renderizado

```jsx
console.log("%c 1: render antes useEffect ", "color: MediumSpringGreen");

//luego llegaramos a este useEffect
useEffect(() => {
  console.log("useEffect", count);
  document.title = count; // este cout ya est√° actualizado
});

//finalmente haremos este render despu√©s
console.log("%c 2: render despu√©s useEffect ", "color: LightCoral");
```

Lo cierto es que estamos definiendo una funci√≥n pero no la estamos ejecutando. Si se fijas le estamos pasando a useEffect una funci√≥n,
**no le estamos pasando su ejecuci√≥n**
entonces lo que va a pasar:

<br />

**1.** Primero renderiza este console.log() antes del useEffect

```jsx
console.log("%c 1: render antes useEffect ", "color: MediumSpringGreen");
```

**2.** Vera este useEffect y dira de acuerdo me quedo con esta funci√≥n, para ejecutarla despu√©s porque es un side effects

```jsx
useEffect(() => {
  console.log("useEffect", count);
  document.title = count; // este cout ya esta actualizado
});
```

**3.** Posteriormente seguir√° haciendo todo el render o finalmente retornar√° un valor

```jsx
console.log("%c 2: render despu√©s useEffect ", "color: LightCoral");

  return (
    <div>
      <h1>{count}</h1>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        + 1
      </button>
      <button
        onClick={() => {
          setCount(count + 2);
        }}
      >
        + 2
      </button>
      <button
        onClick={() => {
          setCount(count + 3);
        }}
      >
        + 3
      </button>
    </div>
  );
};

export default App;
```

<br />

Cuando retorne se pintar√° en nuestra pantalla los botones de la **interfaz, el count 0, +1,+2 y +3** el renderizado ya ha terminado.

<br />

Lo siguiente que hace React cuando termina el renderizado, es venir y decir ¬ø durante este renderizado hay que ejecutar alg√∫n useEffect ? la respuesta es que si, entonces ejecuta este useEffect ante que se produzca el siguiente renderizado y de esta manera podemos verlo en consola.

<br />

![console](/static/images/console.png)

<br />

Cada vez que provoquemos un renderizado esto volver√° a ser as√≠.

<br />

![console2](/static/images/console2.png)

<br />

**useEffect se ejecuta de forma as√≠ncrona, es decir, "no es inmediatamente" despu√©s del render de forma s√≠ncrona, si no que es de forma as√≠ncrona y que implica que no podemos saber el momento exacto cuando se ejecuta, podemos aproximarlo porque sabemos que es despu√©s del render, pero no sabemos si es 10ms, 12ms etc.**

No es como **useLayout** que ese si se ejecuta despu√©s del render forma s√≠ncrona, esto no nos importa, pero tiene sentido a la hora de hablar de m√©tricas, podemos ver que hay un peque√±o delay entre que se ejecuta y termina useEffect.

<br />

### useEffect sabemos que se ejecuta despu√©s de un render y se ejecuta ante del siguiente, eso nos garantiza react

Por eso es que este useEffect se ejecuta en el primer renderizado
y por eso aqu√≠ aparece un 0. En este caso podr√≠amos evitar que se ejecute en primer renderizado utilizando un sencillo if

```jsx
useEffect(() => {
  if (count === 0) return; //la fn() se ejecuta pero no produce resultado
  console.log("useEffect", count);
  document.title = count; // est√© count ya esta actualizado
});
```

<br />

<Image
  src="/static/images/console3.png"
  alt="setcount2"
  width={190}
  height={450}
/>

### Por supuesto necesitamos mucho mayor control de cuando se debe ejecutar un useEffect o no. Eso lo podemos hacer con las dependencias.

## üíª Code Example useEffect

[link code](https://codesandbox.io/s/useeffect-tq5wpx?file=/src/App.js)
