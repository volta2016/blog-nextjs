---
title: "This"
image: "/static/images/this.jpg"
cover: "/static/images/opengraph/this-cover-voltadev-blog.jpg"
author: "/static/images/author-voltadev.png"
nameauthor: "voltadev"
published: "02-18-2022"
description: "¬øQu√© es this en JavaScript?"
---

## "¬øQu√© es this en JavaScript?"

> La palabra clave **this** tiene en Javascript un comportamiento diferente al de otros lenguajes, pero por lo general, su valor hace referencia al propietario de la funci√≥n que la est√° invocando o en su defecto, al objeto donde dicha funci√≥n es un m√©todo.

## Palabra reservada this

**this** es una palabra que hace referencia al **objeto contexto** que estamos trabajando

<br />

1. Lo primero que tenemos que entender cuando tenemos javascript en los navegadores:

```js
console.log(this);
```

**this** va hacer referencia al objeto global y este objeto se llama **window**

<br />

![ecmascript](/static/images/window.png "window")

<br />

si ejecutamos este c√≥digo en **node JavaScript** nos va a devolver **global** que en node ser√≠a el objeto global. En node no existe **window**.

<br />

- Entonces si el objeto global en el navegador es window, esto validar√≠a a true

```JavaScript
console.log(this === window); //true
```

ahora si ejecutamos el siguiente c√≥digo nos va devolver en consola **contexto global**

```JavaScript
this.nombre = "Contexto global"; //creamos una variable al window
console.log(this.nombre); //contexto global
```

---

## ‚≠ê This ejemplos pr√°cticos

A continuaci√≥n vamos a analizar el comportamiento de **this** con diferentes ejemplos.

## 1. Ejemplo:

```JavaScript
this.nombre = "Contexto global";
console.log(this.nombre);

function imprimir() {
  console.log(
    this.nombre +
      " sigue imprimiendo la variable global ya que seguimos en el √°mbito (scope)"
  );
}

imprimir();
```

- Lo primero que realizamos fue crear una variable al window, pero üëÄ ojo, sin
  la necesidad de crear variables con: var, const y let. Pedemos hacer lo
  siguiente.

```JavaScript
this.nombre = "Contexto global";
```

Aqu√≠ podemos apreciar que le asignamos un nombre
**Contexto global** esto ser√≠a window en nuestro archivo.

Luego de esto, podemos ver en la consola del navegador que despu√©s de todas las propiedades y metodos tenemos a **Contexto global**

<br />

![ecmascript](/static/images/contexto-global.png "window")

<br />
Luego de esto creamos la funci√≥n para imprimir este nombre

```JavaScript
function imprimir() {
  console.log(
    this.nombre +
      " sigue imprimiendo la variable global ya que seguimos en el √°mbito (scope)"
  );
}

imprimir();
```

## Conclusiones

- <span className="list-icon">‚úÖ </span> Al ejecutar imprimir, sigue imprimiendo
  **Contexto global** por que estamos en el √°mbito general "en window para los navegadores".
- <span className="list-icon">‚úÖ </span> As√≠ que sigo imprimiendo el contexto global
  al ejecutar la funci√≥n imprimir()

## 2. Ejemplo:

Ahora vamos analizar donde se esta ejecutando el this.name dentro de mi const **obj**

```JavaScript
this.nombre = "Contexto global";

const obj = {
  name: "Contexto Objeto",
  imprimir: function () {
    console.log(this.name);
  },
};

obj.imprimir();
```

Vemos que this se esta ejecutando dentro del scope de la propiedad imprimir apuntando \*name: "Contexto Objeto", la funci√≥n an√≥nima ha sido creada dentro del contexto del objeto, por eso a la hora de llamar
al m√©todo

```JavaScript
obj.imprimir();
```

me marca **Contexto Objeto** y no **Contexto global.**

<br />

Cuando nos referimos al Contexto global ser√≠a la variable que asignamos al window

## 3. Ejemplo:

Antes de comenzar tenemos que tener en cuenta que esto en JavaScript es un
Scope o ambito.

```JavaScript
{
  //bloque
}
```

Vamos a crear un **obj2** üëÄ pero ojo, la propiedad imprimir del **obj2** va va hacer referencia a la funci√≥n que tenemos declarada en el **scope global**
del archivo que es **imprimir().**

```JavaScript
console.log(this);

this.nombre = "Contexto global";
console.log(this.nombre);

function imprimir() {
  console.log(this.nombre);
}

imprimir();

const obj = {
  name: "Contexto Objeto",
  imprimir: function () {
    console.log(this.name);
  },
};

obj.imprimir();

const obj2 = {
  name: "Contexto Objeto 2",
  imprimir, // asigne como valor una funci√≥n que ya estaba declarada
};

obj2.imprimir();
```

Recordemos a los **shorthand** de los objetos si el nombre de la propiedad y el nombre de la variable que guarda el valor es el mismo, simplemete lo podemos omitir.

### Sin shorthand

```JavaScript
const obj2 = {
  name: "Contexto Objeto 2",
  imprimir: imprimir,
};
```

### Con shorthand

```JavaScript
const obj2 = {
  name: "Contexto Objeto 2",
  imprimir,
};
```

Esto es simplificaci√≥n de sintaxis.

## Conclusiones

- <span className="list-icon">‚úÖ </span> Resumen del ejemplo, simplemente asignamos
  una funci√≥n que ya estaba declarada

- <span className="list-icon">‚úÖ </span> Como esta funci√≥n <b>imprimir()</b> ya esta
  asignada al obj2. El contexto en donde se encuentra en este caso es this.nombre
  es el contexto de la propiedad <b>imprimir</b> que aplicamos con el shorthand

## 4. Arrow Function

### ¬ø Que pasa si en lugar una funci√≥n an√≥nima mejor utilizamos las arrow function ?

```JavaScript
this.nombre = "Contexto global";
console.log(this.nombre);

function imprimir() {
  console.log(this.nombre);
}

imprimir();

const obj = {
  name: "Contexto Objeto",
  imprimir: function () {
    console.log(this.name);
  },
};

obj.imprimir();

const obj2 = {
  nombre: "Contexto Objeto 2",
  imprimir, // asigne como valor una funci√≥n que ya estaba declarada
};

obj2.imprimir();

// comportamiento con arrow function
const obj3 = {
  nombre: "Contexto Objeto 3",
  imprimir: () => {
    console.log(this.nombre);
  },
};

obj3.imprimir();
```

Esto son los **console.log()** del c√≥digo anterior pero nos vamos a enfocar en **obj3**
que tiene un arrow function

<br />

![this](/static/images/console-this.png "this con")

<br />

- Esta es el console del **obj3** al invocar la arrow function
  linea 42:
  - <b>Contexto global</b>

Aqu√≠ hay un detalle, hasta cierto punto las arrow function soluciona pero tambi√©n crea conflictos.
Aqu√≠ lo que hace una arrow function, es mantener un enlace del contexto que ha sido creado el objeto donde aparece, a diferencia de esta funci√≥n an√≥nima, que es una funci√≥n como tal, maneja su propio scope.

```JavaScript
const obj = {
  name: "Contexto Objeto",
  imprimir: function () {
    console.log(this.name);
  },
};

obj.imprimir();
```

### Las arrow function no manejan su propio scope

El contexto de la palabra this, lo que hace es tomarlo directamente del padre del objeto en el que se ha creado **es por eso que no esta imprimiendo el contexto global.** Esto enlaza el contexto de padre al hijo, es muy similar a lo que hace el m√©todo **bind,** de hecho el m√©todo **call** **apply** y **bind** est√°n muy relacionados al m√©todo this, entonces esa es una de las caracter√≠sticas por las cuales cuando est√°s trabajando en la creaci√≥n de un objeto y dentro de ese objeto tienen propiedades, tienes m√©todos y esos m√©todos van a interactuar con propiedades de objeto literal.
**NO** se recomienda que utilices **arrow function** si no utilizas funciones an√≥nimas.

¬ø Por qu√© ?

> > Las arrow function no crean un scope, se salta el scope en que ha sido creado, obedece al contexto global en el cual ha sido creado el objeto

Por eso es que **obj3.imprimir();** en este caso como obj3 ha sido creado en el contexto global, por es que nos esta imprimiendo:

- <span className="list-icon">üåü</span> <b>Contexto Global</b>
- <span className="list-icon">üåü</span> <b>obj3</b> fue creado en dicho contexto

- <span className="list-icon">üåü</span> <b>las arrow function</b> no generan scope
  a diferencia de las funciones an√≥nimas

## 5. funci√≥n constructora que crea su propio scope

Vamos a crear una funci√≥n constructora que se va llamar **Persona**, persona va recibir un nombre dentro, le vamos a decir **this.nombre = nombre;**

Luego vamos a retornar el <span>**console.log(this.nombre);**</span>
en parte final del c√≥digo a una variable le asignamos una instancia de Persona y le pasamos un nombre como argumento.

```JavaScript
function Persona(nombre) {
  this.nombre = nombre;
  return console.log(this.nombre);
}

let kyo = new Persona("Kyo");
```

Que pasa si en vez de retornar el console.log() su ejecuci√≥n,
probamos otra sintaxis pero antes:

üëÄ Recordemos que las funciones son ciudadanos de primera clase
sirven para crear:

- <span className="list-icon">‚úÖ </span> objetos
- <span className="list-icon">‚úÖ </span> prototipos
- <span className="list-icon">‚úÖ </span> se pueden pasar como parametros
- <span className="list-icon">‚úÖ </span> las podemos retornar como el resultado de
  otra funci√≥n

Eso en el mundo de la programaci√≥n en javascript se conoce como **clausura o closure**
porque estamos envolviendo un funci√≥n dentro de una funci√≥n y la estamos retornando.

retomando lo que vamos a retornar dentro de Persona, vamos crear una funci√≥n an√≥nima y la mandamos en el return, luego esa funci√≥n ejecuta la linea
del console.log()

```JavaScript
function Persona(nombre) {
  this.nombre = nombre;
  // return console.log(this.nombre);
  return function () {
    console.log(this.nombre);
  };
}

let kyo = new Persona("Kyo");
```

Vemos que esto es solo la declaraci√≥n de una funci√≥n an√≥nima

```JavaScript
return function () {
  console.log(this.nombre);
};
```

para que esto se invoque yo tendriamos que ejecutar la instancia de Persona, que este caso es la variable kyo

```JavaScript
kyo();
```

vamos a ejecutarla como m√©todo, porque finalmente esta retornando un funci√≥n

```JavaScript
function Persona(nombre) {
  this.nombre = nombre;
  //return console.log(this.nombre);
  return function () {
    console.log(this.nombre, "return f()");
  };
}

let kyo = new Persona("Kyo");
kyo();
```

Vamos a ver que me retorna en consola

```JavaScript
Contexto global
```

### Ahora ¬ø por qu√© me est√° diciendo Contexto global ?

Recapitulemos que cada funci√≥n crea un contexto salvo las arrow function que heredan el contexto en el cual ha sido creada.

- ¬ø Que pasa aqu√≠ ? la funci√≥n constructora tiene su propio scope y le estoy pasando como argumento un nombre
  <br />
- Dentro de la funci√≥n constructora estoy asignando una variable, **this.nombre = nombre;** es igual al nombre que recibe como par√°metro

Entonces cuando ejecutamos este directamente al return **si existe**

```JavaScript
return console.log(this.nombre);
```

Esta nueva funci√≥n an√≥nima crea un nuevo scope, crea un nuevo contexto internamente, no tiene ninguna propiedad nombre

```JavaScript
return function () {
  console.log(this.nombre, "return f()");
};
```

Entonces como no tiene un propiedad nombre, lo √∫nico que hace es regresar y leer el this del Contexto Global
por eso en consola nos muestra **Contexto global** en lugar de **Kyo**

¬ø Cu√°l ser√≠a la soluci√≥n con Ecmascript 2015 en lugar de tenerlo en una funci√≥n an√≥nima ?

üß† Recordemos que las arrow function no crean scope interno

Entonces en lugar de retornarlo como una funci√≥n an√≥nima la **retornamos como una arrow function**

```JavaScript
return () => console.log(this.nombre, "return f()");
```

### Antes de las que existieran las arrow function de esta forma los solucionamos

Us√°bamos var, pero ahora como tenemos const lo vamos aplicar con const, ya que con var es mala pr√°ctica.
Vamos a crear una constante que se va llamar **that**

<br />

- <span className="list-icon">‚úÖ </span> <b>that</b> va hacer referencia al this
  de la funci√≥n constructora{" "}

<br />

Cuando miramos esto en c√≥digo, sacamos la conclusi√≥n de que lo que quiso hacer es guardar el contexto this de esta funci√≥n constructora para que si despu√©s retornas una funci√≥n an√≥nima, puedas recuperar ese this

```JavaScript
function PersonaTwo(nombre) {
  const that = this; // es igual al this de la funci√≥n
  that.nombre = nombre;
  //return console.log(this.nombre);
  return function () {
    console.log(that.nombre, "that solution");
  };
}

let asuka = new PersonaTwo("Asuka");
asuka();
```
