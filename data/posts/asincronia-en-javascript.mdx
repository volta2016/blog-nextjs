---
title: "Asincron√≠a en JavaScript"
image: "/static/images/asincronismo-en-javascript.png"
cover: "/static/images/opengraph/asincronismo-en-javascript-cover.png"
author: "/static/images/author-voltadev.png"
nameauthor: "voltadev"
published: "06-21-2022"
description: "Asincron√≠a en JS - Ejemplos Pr√°cticos"
---

> Hola bienvenidos al blog üòÄ este post vamos a ver que es la **As√≠ncronia en JavaScript**
> con ejemplos gr√°ficos y pr√°cticos.

## Asincron√≠a

La asincron√≠a es uno de los pilares fundamentales de Javascript, ya que es un lenguaje
de programaci√≥n de un s√≥lo subproceso o hilo **(single thread),** lo que significa que
s√≥lo puede ejecutar una cosa a la vez.

> **single thread** un solo hilo de ejecuci√≥n

Si bien los idiomas de un s√≥lo hilo simplifican la escritura de c√≥digo,
porque no tiene que preocuparse por los problemas de concurrencia, esto tambi√©n
significa que no puede realizar operaciones largas como el acceso a la red,
sin bloquear el hilo principal.

<br />

Imagina que solicitas datos de una API. Dependiendo de la situaci√≥n, el servidor
puede tardar un tiempo en procesar la solicitud mientras bloquea el hilo principal y hace
que la p√°gina web no responda.

<br />

Ah√≠ es donde entra en juego la üì≤ü§ô Asincron√≠a que permite realizar largas solicitudes de red **sin bloquear el hilo principal.**

<br />

- <span className="list-icon">‚úÖ</span> JavaScript fue dise√±ado para ser ejecutado
  en navegadores, trabajar con peticiones sobre la red y procesar las interacciones
  de usuario, al tiempo que mantiene una interfaz fluida.

<br />

- <span className="list-icon">‚úÖ</span> Javascript usa un modelo as√≠ncrono y no bloqueante,
  con un loop de eventos implementado <b>en un s√≥lo hilo, (single thread)</b> para
  operaciones de entrada y salida (input/output).

<br />

**Modelo as√≠ncrono y no bloqueante: Gracias a esta soluci√≥n, Javascript es √°ltamente concurrente a pesar de emplear un s√≥lo hilo.**

## Antes de explicar como funciona el modelo de JavaScript es importante entender algunos conceptos:

## S√≠ncrono y As√≠ncrono

Se refiere a ¬ø cu√°ndo tendr√° lugar la respuesta ?

<br />

**S√≠ncrono:** La respuesta sucede en el presente, una operaci√≥n s√≠ncrona esperar√° el resultado.

<br />

**As√≠ncrono:** La respuesta sucede a futuro, una operaci√≥n as√≠ncrona no esperar√° el resultado.
Con lo anterior en JavaScript podemos tener:

<br />

**C√≥digo s√≠ncrono y bloqueante o C√≥digo as√≠ncrono y no bloquenate**

## Operaciones de CPU y de Entrada y Salida

- <span className="list-icon">‚úÖ</span> <b>Operaciones CPU:</b> Aquellas que pasan
  el mayor tiempo consumiendo Procesos del CPU, por ejemplo, la escritura de ficheros.

<br />

- <span className="list-icon">‚úÖ</span> <b>Operaciones de Entrada y Salida:</b> Aquellas
  que pasan la mayor parte del tiempo esperando la respuesta de una petici√≥n o recurso,
  como la solicitud a una API o BD.

<br />

- <span className="list-icon">‚úÖ</span> <b>Concurrencia y Paralelismo.</b>

<br />

**Concurrencia:** cuando dos o m√°s tareas progresan simult√°neamente.

<br />

**Paralelismo:** cuando dos o m√°s tareas se ejecutan, al mismo tiempo.
Bloqueante y No Bloqueante
Se refiere a como la fase de espera de las operaciones afectan a nuestra aplicaci√≥n:

## Bloqueante y No Bloqueante

Se refiere a como la fase de espera de las operaciones afectan a nuestra aplicaci√≥n:

<br />

**Bloqueante:** Son operaciones que no devuelven el control a nuestra aplicaci√≥n hasta que se ha completado. Por tanto el thread queda bloqueado en estado de espera.

<br />

**No Bloqueante:** Son operaciones que devuelven inmediatamente el control a nuestra aplicaci√≥n, independientemente del resultado de esta. En caso de que se haya completado,
devolver√° los datos solicitados. En caso contrario **si la operaci√≥n no ha podido ser satisfecha** podr√≠a devolver un c√≥digo de error.

## Single thread y Multi thread

Un hilo la unidad b√°sica de ejecuci√≥n de un proceso, cada que abres un programa, como el navegador
o tu editor de c√≥digo, se levanta un proceso en tu computadora e internamente este puede tener uno
o varios hilos (threads) ejecut√°ndose para que el proceso funcione.

<br />

> üëÄ **Ojo, que no es Multi-Threading.** En JavaScript, existe un solo **Thread,** y el **asincronismo no crea otro thread.**
> Los **"procesos"** no necesariamente se ejecutan de forma simultanea, sino que se delegan y se ejecutan en
> ordenes diferentes, ya no secuenciales a como fueron escritos en el codigo originalmente. Algunas cosas
> pasan a **"segundo plano"** y van a ser procesadas solo cuando el thread este desocupado. Entonces en realidad
> todo se ejecuta secuencialmente pero lo que est√° en una promesa o en un await se ejecuta en un tiempo X, cuando
> el thread este desocupado, y no lo bloquea, entonces si tiene que renderizar algo, lo puede hacer.

## üíª Programa funci√≥n as√≠ncrona

Vamos a analisar el siguiente c√≥digo y ver el comportamiento del c√≥digo as√≠ncrono.
Gracias a la API del navegador nos brinda **setTimeout.**

```js
function resolAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("resolved");
    }, 2000);
  });
}

async function asyncCall() {
  console.log("calling");
  const result = await resolAfter2Seconds(); //esto ser√≠a una promesa? Si es la soluci√≥n a la promesa
  console.log(result);
}

asyncCall();
```

vamos a ver c√≥mo se ejecuta el anterior programa paso a paso:

<br />

![Program Async Function](/static/images/program-async-function.png)

<br />

![event-loop](/static/images/event-loop.png)

<br />

Como podemos ver en el gr√°fico el **event loop o bucle de eventos** es un proceso que espera a que la pila de llamadas se elimine
antes de enviar devolucionesde llamada de la cola de tareas a la pila de llamadas. Una vez que la pila est√° limpia, el ciclo de eventos se activa y verifica la cola de tareas para ver si hay devoluciones de llamada disponibles.

<br />

- <span className="list-icon">‚úÖ</span> Las funciones son empujadas al call stack
  cuando son invocadas y se sacan cuando devuelven un valor.

<br />

- <span className="list-icon">‚úÖ</span> El callback es a√±adido al call stack para
  luego ser ejecutado. Una vez retorna un valor, este es sacado de call stack.

<br />

- <span className="list-icon">‚úÖ</span> El Event Loop mira hacia el callback queue
  y al call stack. Si el call stack est√° vac√≠o, este empuja el primer elemento de
  la cola en el stack.

## üëÅÔ∏è Analizaremos la ejecuci√≥n del c√≥digo en memoria

![execution of memory](/static/images/execution-of-memory.png)

# ü§ì Conclusiones

Bueno para finalizar les dejo un resumen de los conceptos que hemos aplicado en programa pero en simples palabras, espero
que te sirva este post, estuve pensando mucho como mostrar este mapa gr√°fico, junto con el programa (c√≥digo).
Espero que haya ayudado.
Para profundizar en el **event loop** les dejo la siguiente charla.

<br />

üìπ [Event loop](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

<br />

**La programacioÃÅn asiÃÅncrona se refiere a la ejecucioÃÅn de procesos
ejecutaÃÅndose de manera simultaÃÅnea (Multi thread).**

<br />

**Proceso AsiÃÅncrono**
La respuesta sucede a futuro, una operacioÃÅn asiÃÅncrona no esperaraÃÅ el resultado
continua con el resto de tareas.

<br />

**As√≠ncrono:** cuando algo no depende de otra cosa para continuar eso es as√≠ncrono (cuando ejecuta 2 o m√°s cosas en paralelo)

<br />

**S√≠ncrono:** la l√≠nea de abajo depende de l√≠nea de arriba en la ejecuci√≥n del programa.
